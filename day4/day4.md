# LeetCode Day 4 - 2的幂

> **题目链接**: [231. 2的幂 - LeetCode](https://leetcode.cn/problems/power-of-two/)  
> **难度**: 简单  
> **标签**: 位运算, 递归, 数学

## 解题思路

### 算法：位运算

1. **核心思想**：利用2的幂在二进制表示中的特殊性质
2. **关键观察**：2的幂的二进制表示只有一个位为1，其余位都为0
3. **位运算技巧**：`n & (n-1)` 可以清除最低位的1

### 为什么 `n & (n-1) == 0` 能判断2的幂？

#### 数学证明

**要证明的命题：** 当且仅当 `n` 是2的幂时，`n & (n-1) == 0`

**证明过程：**

1. **2的幂的二进制特征**
   
   当 `n = 2^k` 时，n的二进制表示为：
   ```
   n = 2^k:     10...0  (第k位为1，其余k个位为0)
   n-1 = 2^k-1: 01...1  (前k位都为1)
   ```

2. **按位与运算**
   
   ```
   n & (n-1) = 10...0 & 01...1 = 00...0 = 0
   ```
   
   因此，当n是2的幂时，`n & (n-1) == 0` 成立。


## 代码实现

### 方法1：位运算算法（推荐解法）

```cpp
#include<iostream>
#include<windows.h>
using namespace std;

bool isPowerOfTwo(int n) {
    // 条件1: n > 0 (排除负数和0)
    // 条件2: n & (n-1) == 0 (2的幂的位运算特性)
    return n > 0 && (n & (n-1)) == 0;
}

int main() {
    int a = 16;
    cout << "16 是否为2的幂: " << isPowerOfTwo(a) << endl;
    
    system("pause");
    return 0;
}
```

### 方法2：循环除法算法

```cpp
bool isPowerOfTwo_Method2(int n) {
    if (n <= 0) return false;
    
    while (n % 2 == 0) {
        n /= 2;
    }
    
    return n == 1;
}
```

**循环除法思路：**
- 不断除以2，如果能整除就继续
- 最后如果剩下1，说明原数是2的幂
- 时间复杂度：O(log n)


## 算法分析

### 复杂度对比

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| 位运算 | O(1) | O(1) | 最优解，常数时间 |
| 循环除法 | O(log n) | O(1) | 直观易懂，但较慢 |

### 位运算算法优势

1. **时间效率**：只需要一次位运算操作
2. **空间效率**：不需要额外空间
3. **代码简洁**：一行代码解决问题
4. **适用范围**：适合所有32位整数范围

## 运行示例

### 测试输出
```
16 是否为2的幂: 1

完整测试结果:
数字    二进制          是否为2的幂
------------------------------------
1       00000001        是
2       00000010        是
3       00000011        否
4       00000100        是
5       00000101        否
8       00001000        是
16      00010000        是
32      00100000        是
64      01000000        是
100     01100100        否
128     10000000        是
256     00000000        是
```

### 执行过程分析（n=16）

```
n = 16 (二进制: 10000)
n-1 = 15 (二进制: 01111)
n & (n-1) = 10000 & 01111 = 00000 = 0

由于 16 > 0 且 16 & 15 == 0
因此 16 是 2 的幂
```

## 关键点总结

1. **位运算技巧**：`n & (n-1)` 能清除最低位的1，利用这个性质判断2的幂
2. **边界处理**：必须检查 `n > 0`，排除负数和0的情况

