# LeetCode Day 1 - 盛最多水的容器

## 题目描述

给定一个长度为 n 的整数数组 height。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

## 示例

### 示例 1：
```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

### 示例 2：
```
输入：height = [1,1]
输出：1
```

## 解题思路

### 算法：双指针

1. **核心思想**：使用双指针从数组两端向中间移动
2. **面积计算**：面积 = 两指针间距离 × min(左指针高度, 右指针高度)
3. **指针移动策略**：总是移动较短的一边，因为移动较长的一边不可能得到更大的面积

### 为什么移动较短的指针？

- 容器的高度由较短的线决定
- 如果移动较长的指针，宽度减少，而高度仍然受较短指针限制
- 移动较短的指针，虽然宽度减少，但有可能遇到更高的线，从而增加总面积

## 代码实现

### 方法1：暴力算法（时间复杂度 O(n²)）

```cpp
// 暴力解法：枚举所有可能的两条线
int maxArea(vector<int>& height) {
    int max_area = 0;
    int length = height.size();
    
    for(int i = 0; i <= length-1; i++)
    {
        for(int j = i+1; j <= length-1; j++)
        {
            int area = min(height[i], height[j]) * (j-i);
            max_area = max(max_area, area);
        }
    }
    
    return max_area;
}
```

**暴力算法思路：**
- 枚举所有可能的两条线的组合
- 对于每一对 (i, j)，计算面积 = min(height[i], height[j]) × (j-i)
- 保留最大的面积值

### 方法2：双指针算法（时间复杂度 O(n)）

```cpp
// 优化解法：双指针
int maxArea(vector<int>& height) {
    int max_area = 0;
    int length = height.size();
    int left = 0, right = length - 1;
    
    while(left < right)
    {
        // 计算当前面积
        int current_area = (right - left) * min(height[left], height[right]);
        max_area = max(max_area, current_area);
        
        // 移动较短的指针
        if(height[left] < height[right]) 
            left++;
        else 
            right--;
    }
    
    return max_area;
}
```

**双指针算法思路：**
- 使用两个指针从数组两端开始
- 每次移动较短的指针，因为移动较长的指针不可能得到更大面积
- 只需要遍历一次数组，大大提高了效率

## 算法分析

### 暴力算法复杂度
- **时间复杂度：O(n²)** - 需要两层嵌套循环枚举所有可能的组合
- **空间复杂度：O(1)** - 只使用了常数级别的额外空间

### 双指针算法复杂度
- **时间复杂度：O(n)** - 每个元素最多被访问一次
- **空间复杂度：O(1)** - 只使用了常数级别的额外空间

### 算法对比
| 算法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| 暴力算法 | O(n²) | O(1) | 思路直观，但效率低 |
| 双指针 | O(n) | O(1) | 效率高，是最优解 |

## 运行示例

### 输入格式
```
[1,8,6,2,5,4,8,3,7]
```

### 输出
```
49
```

### 执行过程
1. left=0 (height=1), right=8 (height=7) → area = 8×1 = 8
2. left=1 (height=8), right=8 (height=7) → area = 7×7 = 49
3. left=1 (height=8), right=7 (height=3) → area = 6×3 = 18
4. ... (继续移动直到 left >= right)

## 关键点总结

1. **双指针技巧**：从两端向中间移动，避免了 O(n²) 的暴力解法
2. **贪心策略**：始终移动较短的指针
3. **数学思维**：面积 = 宽度 × 高度，高度由较短边决定

## 其他测试用例

```cpp
// 测试用例1
输入：[1,1] 
输出：1

// 测试用例2  
输入：[4,3,2,1,4]
输出：16

// 测试用例3
输入：[1,2,1]
输出：2
```

## 学习收获

- 理解了双指针算法的应用场景
- 掌握了贪心策略的思维方式
- 学会了从 O(n²) 优化到 O(n) 的技巧